// Include MicroPython API.
#include "py/runtime.h"

#include "py/builtin.h"
#include "py/runtime.h"
#include "py/mpconfig.h"
#include "py/objstr.h"
#include "py/obj.h"
#include "py/stream.h"
#include "py/reader.h"
#include "extmod/vfs.h"

#include <stdio.h>
#include <string.h>
#include <errno.h>


#include "blst/bindings/blst.h"
#include "mod_blst.h"
/* #include "blst/src/bytes.h" */
/* #include "blst/src/vect.h" */


void *mp_alloca(size_t size)
{
    return gc_alloc(size ? size : 1, true);
}

static mp_obj_t read_file(mp_obj_t self_in) {
    // file = open(args[0], "rb")
    mp_obj_t f_args[2] = {
        self_in,
        MP_OBJ_NEW_QSTR(MP_QSTR_rb),
    };
    mp_obj_t file = mp_vfs_open(2, &f_args[0], (mp_map_t *)&mp_const_empty_map);

    // data = file.read()
    mp_obj_t dest[2];
    mp_load_method(file, MP_QSTR_read, dest);
    mp_obj_t data = mp_call_method_n_kw(0, 0, dest);

    // file.close()
    mp_stream_close(file);
    return data;
}


static mp_obj_t write_file(mp_obj_t self_in, mp_obj_t data_in) {
    // file = open(args[0], "rb")
    mp_obj_t f_args[2] = {
        self_in,
        MP_OBJ_NEW_QSTR(MP_QSTR_wb),
    };
    mp_obj_t file = mp_vfs_open(2, &f_args[0], (mp_map_t *)&mp_const_empty_map);

    // data = file.read()
    mp_obj_t dest[3];
    mp_load_method(file, MP_QSTR_write, dest);
    dest[2] = data_in;
    mp_obj_t n_bytes = mp_call_method_n_kw(1, 0, dest);

    // file.close()
    mp_stream_close(file);
    return n_bytes;
}

/* void blst_keygen(pow256 SK, const void *IKM, size_t IKM_len, */
/*                             const void *info, size_t info_len) */


/* void blst_keygen(blst_scalar *out_SK, const bl_byte *IKM, size_t IKM_len, */
/*                  const bl_byte *info DEFNULL, size_t info_len DEFNULL); */

/* https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature#section-2.3 */
/* The KeyGen procedure described in this section generates a secret key SK deterministically from a secret octet string IKM. SK is guaranteed to be nonzero, as required by KeyValidate (Section 2.5).¶ */

/* KeyGen uses HKDF [RFC5869] instantiated with the hash function H.¶ */

/* For security, IKM MUST be infeasible to guess, e.g., generated by a trusted source of randomness. IKM MUST be at least 32 bytes long, but it MAY be longer.¶ */


static mp_obj_t mod_blst_keygen(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {
    // Extract the ints from the micropython input objects.
    //
	static const mp_arg_t allowed_args[] = {

        { MP_QSTR_IKM, MP_ARG_REQUIRED | MP_ARG_OBJ, {.u_rom_obj = mp_const_none }},
    };

    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
    mp_arg_parse_all(n_args, pos_args, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);


    mp_check_self(mp_obj_is_str_or_bytes(args[0].u_obj));


    // check if IKM is a string/path
    mp_obj_t IKM_data;
    blst_scalar *pkey = NULL; 

    if (!(mp_obj_is_type(args[0].u_obj, &mp_type_bytes))) {
        IKM_data = read_file(args[0].u_obj);
    } else {
        IKM_data = args[0].u_obj;
    }


    /* return IKM_data; */
    //Parse secret seed
    size_t IKM_len;
    const byte *IKM_seed = (const byte *)mp_obj_str_get_data(IKM_data, &IKM_len);

    blst_keygen(pkey, IKM_seed, IKM_len, NULL, 0);
    /* /1* /2* unsigned char output_buf[key_len]; *2/ *1/ */

    return mp_const_none;
    

}
// Define a Python reference to the function above.
static MP_DEFINE_CONST_FUN_OBJ_KW(mod_blst_keygen_obj, 1, mod_blst_keygen);


/* static mp_obj_t mod_blst_sign(mp_obj_t msg_obj, mp_obj_t key_obj) { */ 
/*     // Extract message and key as bytes from Python objects */ 
/*     mp_buffer_info_t msg_buf; */ 
/*     mp_buffer_info_t key_buf; */ 
/*     mp_get_buffer_raise(msg_obj, &msg_buf, MP_BUFFER_READ); */ 
/*     mp_get_buffer_raise(key_obj, &key_buf, MP_BUFFER_READ); */ 
/*     // Check key length (assuming 32 bytes for BLS12-381 secret key) */ 
/*     if (key_buf.len != 32) { mp_raise_msg(&mp_type_ValueError, MP_ERROR_TEXT("Secret key must be 32 bytes")); } */ 
/*     // Prepare blst variables */ 
/*     blst_scalar sk; */ 
/*     blst_p1 sig; */ 
/*     byte sig_bytes[96]; // BLS12-381 signature is 96 bytes in G1 */ 
/*     // Convert key bytes to blst_scalar */ 
/*     blst_scalar_from_be_bytes(&sk, key_buf.buf, key_buf.len); */
/*     // Hash message to point and sign */ 
/*     blst_p1_hash_to(&sig, msg_buf.buf, msg_buf.len, NULL, 0, NULL, 0); */

/*     blst_sign_pk_in_g2(&sig, &sig, &sk); */ 
/*     // Serialize signature to bytes */ 
/*     blst_p1_compress(sig_bytes, &sig); */ 
/*     // Return signature as bytes */ 
/*     return mp_obj_new_bytes(sig_bytes, sizeof(sig_bytes)); } */ 
/* // Define the function object */ 
/* static MP_DEFINE_CONST_FUN_OBJ_2(mod_blst_sign_obj, mod_blst_sign); */


// Define all attributes of the module.
// Table entries are key/value pairs of the attribute name (a string)
// and the MicroPython object reference.
// All identifiers and strings are written as MP_QSTR_xxx and will be
// optimized to word-sized integers by the build system (interned strings).
static const mp_rom_map_elem_t mp_module_blst_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_blst) },
    { MP_ROM_QSTR(MP_QSTR_keygen), MP_ROM_PTR(&mod_blst_keygen_obj) },
    /* { MP_ROM_QSTR(MP_QSTR_sign), MP_ROM_PTR(&mod_blst_sign_obj) }, */
};
static MP_DEFINE_CONST_DICT(mp_module_blst_globals, mp_module_blst_globals_table);

// Define module object.
const mp_obj_module_t mp_module_blst = {
    .base = { &mp_type_module },
    .globals = (mp_obj_dict_t *)&mp_module_blst_globals,
};

// Register the module to make it available in Python.
MP_REGISTER_MODULE(MP_QSTR_blst, mp_module_blst);


// Module globals table STATIC const mp_rom_map_elem_t ublst_module_globals_table[] = { { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_ublst) }, { MP_ROM_QSTR(MP_QSTR_sign), MP_ROM_PTR(&ublst_sign_obj) }, }; STATIC MP_DEFINE_CONST_DICT(ublst_module_globals, ublst_module_globals_table); // Module definition const mp_obj_module_t ublst_user_cmodule = { .base = { &mp_type_module }, .globals = (mp_obj_dict_t*)&ublst_module_globals, }; // Register the module MP_REGISTER_MODULE(MP_QSTR_ublst, ublst_user_cmodule);
//
