// Include MicroPython API.
#include "py/runtime.h"

#include "py/builtin.h"
#include "py/runtime.h"
#include "py/mpconfig.h"
#include "py/objstr.h"
#include "py/obj.h"
#include "py/stream.h"
#include "py/reader.h"
#include "extmod/vfs.h"

#include <stdio.h>
#include <string.h>
#include <errno.h>

#include "mod_blst.h"


void *mp_alloca(size_t size)
{
    return gc_alloc(size ? size : 1, true);
}

static mp_obj_t read_file(mp_obj_t self_in) {
    // file = open(args[0], "rb")
    mp_obj_t f_args[2] = {
        self_in,
        MP_OBJ_NEW_QSTR(MP_QSTR_rb),
    };
    mp_obj_t file = mp_vfs_open(2, &f_args[0], (mp_map_t *)&mp_const_empty_map);

    // data = file.read()
    mp_obj_t dest[2];
    mp_load_method(file, MP_QSTR_read, dest);
    mp_obj_t data = mp_call_method_n_kw(0, 0, dest);

    // file.close()
    mp_stream_close(file);
    return data;
}


static mp_obj_t write_file(mp_obj_t self_in, mp_obj_t data_in) {
    // file = open(args[0], "rb")
    mp_obj_t f_args[2] = {
        self_in,
        MP_OBJ_NEW_QSTR(MP_QSTR_wb),
    };
    mp_obj_t file = mp_vfs_open(2, &f_args[0], (mp_map_t *)&mp_const_empty_map);

    // data = file.read()
    mp_obj_t dest[3];
    mp_load_method(file, MP_QSTR_write, dest);
    dest[2] = data_in;
    mp_obj_t n_bytes = mp_call_method_n_kw(1, 0, dest);

    // file.close()
    mp_stream_close(file);
    return n_bytes;
}
// Helper: Convert Python bytes to C buffer
static int get_buffer(mp_obj_t obj, uint8_t** buf, size_t* len) {
    if (!mp_obj_is_type(obj, &mp_type_bytes)) return 1;

    mp_buffer_info_t bufinfo;
    mp_get_buffer_raise(obj, &bufinfo, MP_BUFFER_READ);

    *buf = bufinfo.buf;
    *len = bufinfo.len;
    return 0;
}

static void blst_p1_from_bytes(blst_p1 *out, const blst_byte in[PUBLIC_KEY_SIZE]){

    blst_p1_affine p1aff;

    blst_p1_uncompress(&p1aff, in);
    blst_p1_from_affine(out, &p1aff);
}

static void blst_p2_from_bytes(blst_p2 *out, const blst_byte in[SIGNATURE_SIZE]){

    blst_p2_affine p2aff;

    blst_p2_uncompress(&p2aff, in);
    blst_p2_from_affine(out, &p2aff);
}

static const blst_byte *get_scheme(int sch){

    // BASIC_SCH 0
    // AUG_SCH 1
    // POP_SCH 2
    // POP_SIG_SCH 3
    const blst_byte *scheme;

    switch (sch) {
        case BASIC_SCH:
            scheme = (const blst_byte *)BASIC_SCHEME_MPL; 
            break;

        case AUG_SCH:
            scheme = (const blst_byte *)AUG_SCHEME_MPL; 
            break;
        case POP_SCH:
            scheme = (const blst_byte *)POP_SCHEME_MPL; 
            break;
        case POP_SIG_SCH:
            scheme = (const blst_byte *)POPSIG_SCHEME_MPL; 
            break;

        default:

            scheme = (const blst_byte *)AUG_SCHEME_MPL; 
            break;
            
            
    }
    return scheme;
}


// Aggregate verification (multiple PKs, messages, and one aggregated signature)
static int bls_aggregate_verify(const uint8_t** pks_in, const uint8_t** msgs, const size_t* msg_lens, size_t num_msgs, const blst_byte agg_sig_in[SIGNATURE_SIZE], int DST) {
    if (num_msgs == 0) return 1;


    const blst_byte *dst = get_scheme(DST); 
    size_t dst_len = strlen((char *)dst); 
   // Initialize pairing context
    blst_pairing* pairing = mp_alloca(blst_pairing_sizeof());
    if (!pairing) return 1;
    blst_pairing_init(pairing, true, dst, dst_len); // Use hash-to-G2

    blst_p1_affine pk_affine;
    blst_p2_affine sig_affine;
    blst_fp12 gtsig;

    blst_p2_uncompress(&sig_affine, agg_sig_in);
    blst_aggregated_in_g2(&gtsig, &sig_affine);
    // Process each PK and message
    for (size_t i = 0; i < num_msgs; i++) {

        blst_p1_uncompress(&pk_affine, pks_in[i]);

        int err = blst_pairing_aggregate_pk_in_g1(pairing, &pk_affine, NULL, msgs[i], msg_lens[i], NULL, 0);

        if (err != BLST_SUCCESS) {
            gc_free(pairing);
            return 1;
        }

    }


    // Commit the pairing
    blst_pairing_commit(pairing);

    int result = blst_pairing_finalverify(pairing, &gtsig)? 0: 1; // SUCCES: ERROR

    gc_free(pairing);
    return result;
}


/* https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature#section-2.3 */
/* The KeyGen procedure described in this section generates a secret key PRIVATE_KEY deterministically from a secret octet string IKM. PRIVATE_KEY is guaranteed to be nonzero, as required by KeyValidate (Section 2.5).¶ */

/* KeyGen uses HKDF [RFC5869] instantiated with the hash function H.¶ */

/* For security, IKM MUST be infeasible to guess, e.g., generated by a trusted source of randomness. IKM MUST be at least 32 bytes long, but it MAY be longer.¶ */


static mp_obj_t mod_blst_keygen(mp_obj_t seed) {

    mp_check_self(mp_obj_is_str_or_bytes(seed));

    // check if IKM is a string/path
    mp_obj_t IKM_data;
    blst_scalar pkey; 

    if (!(mp_obj_is_type(seed, &mp_type_bytes))) {
        IKM_data = read_file(seed);
    } else {
        IKM_data = seed;
    }

    /* //Parse secret seed */
    mp_buffer_info_t seed_buf; 
    mp_get_buffer_raise(IKM_data, &seed_buf, MP_BUFFER_READ); 
    if (seed_buf.len < PRIVATE_KEY_SIZE){

        mp_raise_msg(&mp_type_ValueError, MP_ERROR_TEXT("Seed too small (at least 32 bytes)"));

    }


    blst_keygen(&pkey, (const blst_byte*)seed_buf.buf, seed_buf.len, NULL, 0);

    return mp_obj_new_bytes(pkey.b, PRIVATE_KEY_SIZE);
    

}
// Define a Python reference to the function above.
static MP_DEFINE_CONST_FUN_OBJ_1(mod_blst_keygen_obj, mod_blst_keygen);


static mp_obj_t mod_blst_keygen_v3(mp_obj_t seed) {

    mp_check_self(mp_obj_is_str_or_bytes(seed));

    // check if IKM is a string/path
    mp_obj_t IKM_data;
    blst_scalar sk; 

    if (!(mp_obj_is_type(seed, &mp_type_bytes))) {
        IKM_data = read_file(seed);
    } else {
        IKM_data = seed;
    }

    /* //Parse secret seed */
    mp_buffer_info_t seed_buf; 
    mp_get_buffer_raise(IKM_data, &seed_buf, MP_BUFFER_READ); 
    if (seed_buf.len < PRIVATE_KEY_SIZE){

        mp_raise_msg(&mp_type_ValueError, MP_ERROR_TEXT("Seed size must be at least 32 bytes"));

    }


    blst_keygen_v3(&sk, (const blst_byte*)seed_buf.buf, seed_buf.len, NULL, 0);

    blst_byte sk_serialized[PRIVATE_KEY_SIZE]; 
    blst_bendian_from_scalar(sk_serialized, &sk);
    return mp_obj_new_bytes(sk_serialized, PRIVATE_KEY_SIZE);
    

}
// Define a Python reference to the function above.
static MP_DEFINE_CONST_FUN_OBJ_1(mod_blst_keygen_v3_obj, mod_blst_keygen_v3);


static mp_obj_t mod_blst_derive_master_eip2333(mp_obj_t seed) {

    mp_check_self(mp_obj_is_str_or_bytes(seed));

    // check if IKM is a string/path
    mp_obj_t IKM_data;
    blst_scalar pkey; 

    if (!(mp_obj_is_type(seed, &mp_type_bytes))) {
        IKM_data = read_file(seed);
    } else {
        IKM_data = seed;
    }

    //Parse secret seed
    mp_buffer_info_t seed_buf; 
    mp_get_buffer_raise(IKM_data, &seed_buf, MP_BUFFER_READ); 
    if (seed_buf.len < PRIVATE_KEY_SIZE){

        mp_raise_msg(&mp_type_ValueError, MP_ERROR_TEXT("Seed too small (at least 32 bytes)"));

    }



    blst_derive_master_eip2333(&pkey, (const blst_byte*)seed_buf.buf, seed_buf.len);

    return mp_obj_new_bytes(pkey.b, PRIVATE_KEY_SIZE);
    

}
// Define a Python reference to the function above.
static MP_DEFINE_CONST_FUN_OBJ_1(mod_blst_derive_master_eip2333_obj, mod_blst_derive_master_eip2333);


static mp_obj_t mod_blst_derive_child_eip2333(mp_obj_t parent_sk, mp_obj_t child_index) {

    mp_check_self(mp_obj_is_int(child_index));
    mp_check_self(mp_obj_is_str_or_bytes(parent_sk));

    mp_buffer_info_t sk_buf; 
    mp_get_buffer_raise(parent_sk, &sk_buf, MP_BUFFER_READ); 
     // Validate secret key length (must be 32 bytes) 
    if (sk_buf.len != PRIVATE_KEY_SIZE) { 

        mp_raise_msg(&mp_type_ValueError, MP_ERROR_TEXT("Parent key must be 32 bytes"));
    }
    // Deserialize secret key from bytes 
    blst_scalar psk; 
    memcpy(psk.b, sk_buf.buf, PRIVATE_KEY_SIZE); 

    blst_scalar ckey; 
    int ci = mp_obj_get_int(child_index);
    blst_derive_child_eip2333(&ckey, &psk, (unsigned) ci);

    return mp_obj_new_bytes(ckey.b, PRIVATE_KEY_SIZE);
    

}
// Define a Python reference to the function above.
static MP_DEFINE_CONST_FUN_OBJ_2(mod_blst_derive_child_eip2333_obj, mod_blst_derive_child_eip2333);


static mp_obj_t mod_blst_derive_child_sk_v3(mp_obj_t parent_sk, mp_obj_t child_index) {

    mp_check_self(mp_obj_is_int(child_index));
    mp_check_self(mp_obj_is_str_or_bytes(parent_sk));

    mp_buffer_info_t sk_buf; 
    mp_get_buffer_raise(parent_sk, &sk_buf, MP_BUFFER_READ); 
     // Validate secret key length (must be 32 bytes) 
    if (sk_buf.len != PRIVATE_KEY_SIZE) { 

        mp_raise_msg(&mp_type_ValueError, MP_ERROR_TEXT("Parent key must be 32 bytes"));
    }
    // Deserialize secret key from bytes 
    blst_scalar psk; 
    memcpy(psk.b, sk_buf.buf, PRIVATE_KEY_SIZE); 

    blst_scalar ckey; 
    int ci = mp_obj_get_int(child_index);
    blst_derive_child_sk_v3(&ckey, &psk, (unsigned) ci);

    blst_byte sk_serialized[PRIVATE_KEY_SIZE]; 
    blst_bendian_from_scalar(sk_serialized, &ckey);


    return mp_obj_new_bytes(sk_serialized, PRIVATE_KEY_SIZE);
    

}
// Define a Python reference to the function above.
static MP_DEFINE_CONST_FUN_OBJ_2(mod_blst_derive_child_sk_v3_obj, mod_blst_derive_child_sk_v3);



static mp_obj_t mod_blst_pubk(mp_obj_t sk_obj) { 

    mp_check_self(mp_obj_is_str_or_bytes(sk_obj));
    mp_buffer_info_t sk_buf; 
    mp_get_buffer_raise(sk_obj, &sk_buf, MP_BUFFER_READ); 
     // Validate secret key length (must be 32 bytes) 
    if (sk_buf.len != PRIVATE_KEY_SIZE) { 

        mp_raise_msg(&mp_type_ValueError, MP_ERROR_TEXT("Secret key must be 32 bytes"));
    }
    // Deserialize secret key from bytes 
    blst_scalar sk; 
    memcpy(sk.b, sk_buf.buf, PRIVATE_KEY_SIZE); 
    // Derive public key 
    blst_p1 pk; 
    blst_sk_to_pk_in_g1(&pk, &sk); // min-pubkey-size-type
    // Serialize to compressed form (48 bytes) 
    blst_byte pk_serialized[PUBLIC_KEY_SIZE]; 
    blst_p1_compress(pk_serialized, &pk); 

    return mp_obj_new_bytes(pk_serialized, PUBLIC_KEY_SIZE); }


static MP_DEFINE_CONST_FUN_OBJ_1(mod_blst_pubk_obj, mod_blst_pubk); 

static mp_obj_t mod_blst_sign(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) { 

	static const mp_arg_t allowed_args[] = {
        { MP_QSTR_sk, MP_ARG_REQUIRED | MP_ARG_OBJ, {.u_rom_obj =  mp_const_none} },
        { MP_QSTR_msg, MP_ARG_REQUIRED | MP_ARG_OBJ, {.u_rom_obj = mp_const_none} },
        { MP_QSTR_scheme, MP_ARG_INT | MP_ARG_INT, {.u_int = AUG_SCH} },
    };

    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
    mp_arg_parse_all(n_args, pos_args, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);

    mp_obj_t sk_obj = args[0].u_obj;
    mp_obj_t msg_obj = args[1].u_obj;

    mp_check_self(mp_obj_is_str_or_bytes(sk_obj));
    mp_check_self(mp_obj_is_str_or_bytes(msg_obj));
    // Extract secret key 
    mp_buffer_info_t sk_buf; 
    mp_get_buffer_raise(sk_obj, &sk_buf, MP_BUFFER_READ);

    if (sk_buf.len != PRIVATE_KEY_SIZE) { 

        mp_raise_msg(&mp_type_ValueError, MP_ERROR_TEXT("Secret key must be 32 bytes"));
    }

    blst_scalar sk; 
    memcpy(sk.b, sk_buf.buf, PRIVATE_KEY_SIZE); 
    // Extract message 
    mp_buffer_info_t msg_buf; 
    mp_get_buffer_raise(msg_obj, &msg_buf, MP_BUFFER_READ); 

    // Default DST 
    const blst_byte *dst = get_scheme(args[2].u_int);
    /* const blst_byte *dst = (const byte *)AUG_SCHEME_MPL; */ 
    size_t dst_len = strlen((char *)dst); 

    blst_p2 msg_hash; 
    blst_hash_to_g2(&msg_hash, (const blst_byte*)msg_buf.buf, msg_buf.len, dst, dst_len, NULL, 0); 
    // Sign 
    blst_p2 sig; 
    blst_sign_pk_in_g1(&sig, &msg_hash, &sk); 
    // Serialize signature 
    blst_byte sig_serialized[SIGNATURE_SIZE]; 
    blst_p2_compress(sig_serialized, &sig); 
    return mp_obj_new_bytes(sig_serialized, SIGNATURE_SIZE); }
static MP_DEFINE_CONST_FUN_OBJ_KW(mod_blst_sign_obj, 2, mod_blst_sign);

static mp_obj_t mod_blst_verify(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) { 


	static const mp_arg_t allowed_args[] = {
        { MP_QSTR_pk, MP_ARG_REQUIRED | MP_ARG_OBJ, {.u_rom_obj =  mp_const_none} },
        { MP_QSTR_sig, MP_ARG_REQUIRED | MP_ARG_OBJ, {.u_rom_obj = mp_const_none} },
        { MP_QSTR_msg, MP_ARG_REQUIRED | MP_ARG_OBJ, {.u_rom_obj = mp_const_none} },
        { MP_QSTR_scheme, MP_ARG_INT | MP_ARG_INT, {.u_int = AUG_SCH} },
    };

    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
    mp_arg_parse_all(n_args, pos_args, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);

    mp_obj_t pk_obj = args[0].u_obj;
    mp_obj_t sig_obj = args[1].u_obj;
    mp_obj_t msg_obj = args[2].u_obj;
    mp_check_self(mp_obj_is_str_or_bytes(pk_obj));
    mp_check_self(mp_obj_is_str_or_bytes(msg_obj));
    mp_check_self(mp_obj_is_str_or_bytes(sig_obj));
    // Extract public key (48 bytes) 
    mp_buffer_info_t pk_buf; 
    mp_get_buffer_raise(pk_obj, &pk_buf, MP_BUFFER_READ); 

    if (pk_buf.len != PUBLIC_KEY_SIZE) { 

        mp_raise_msg(&mp_type_ValueError, MP_ERROR_TEXT("Public key must be 48 bytes"));
    }
    // Extract signature (48 bytes) 
    mp_buffer_info_t sig_buf; 
    mp_get_buffer_raise(sig_obj, &sig_buf, MP_BUFFER_READ); 

    if (sig_buf.len != SIGNATURE_SIZE) { 

        mp_raise_msg(&mp_type_ValueError, MP_ERROR_TEXT("Signature must be 96 bytes"));
    }

    // Extract message 
    mp_buffer_info_t msg_buf; 
    mp_get_buffer_raise(msg_obj, &msg_buf, MP_BUFFER_READ); 
    // Default DST 
    const blst_byte *dst = get_scheme(args[3].u_int); 
    size_t dst_len = strlen((char *)dst); 
    // Deserialize public key and signature 
    blst_p1_affine pk_affine; 
    blst_p2_affine sig_affine; 
    blst_p1_uncompress(&pk_affine, pk_buf.buf); 
    blst_p2_uncompress(&sig_affine, sig_buf.buf); 
    BLST_ERROR res = blst_core_verify_pk_in_g1(&pk_affine, &sig_affine, true, msg_buf.buf, msg_buf.len, dst, dst_len, NULL, 0);
    bool valid =  (res == BLST_SUCCESS);
    return mp_obj_new_bool(valid); } 

static MP_DEFINE_CONST_FUN_OBJ_KW(mod_blst_verify_obj, 3, mod_blst_verify);

static mp_obj_t mod_blst_aggregate_sigs(mp_obj_t sigs_obj) {
    mp_obj_t* sig_items;
    size_t num_sigs;
    mp_obj_get_array(sigs_obj, &num_sigs, &sig_items);
    if (num_sigs == 0) {

        mp_raise_msg(&mp_type_ValueError, MP_ERROR_TEXT("No signatures to aggregate"));
    }


    uint8_t** sigs = m_new(uint8_t*, num_sigs);
    size_t* sig_lens = m_new(size_t, num_sigs);
    for (size_t i = 0; i < num_sigs; i++) {
        if (get_buffer(sig_items[i], &sigs[i], &sig_lens[i]) != 0 || sig_lens[i] != SIGNATURE_SIZE) {
            m_del(uint8_t*, sigs, num_sigs);
            m_del(size_t, sig_lens, num_sigs);

            mp_raise_msg(&mp_type_ValueError, MP_ERROR_TEXT("Invalid signature"));
        }
    }

    blst_p2 agg_sig;

    blst_p2_affine sig_aff;
    blst_p2_from_bytes(&agg_sig, sigs[0]);

    for (size_t i = 1; i < num_sigs; i++) {
        blst_p2_uncompress(&sig_aff, sigs[i]);
        blst_p2_add_or_double_affine(&agg_sig, &agg_sig, &sig_aff);
    }

    // Serialize signature 
    blst_byte agg_sig_serialized[SIGNATURE_SIZE]; 
    blst_p2_compress(agg_sig_serialized, &agg_sig); 
    m_del(uint8_t*, sigs, num_sigs);
    m_del(size_t, sig_lens, num_sigs);
    return mp_obj_new_bytes(agg_sig_serialized, SIGNATURE_SIZE);
}
/* static MP_DEFINE_CONST_FUN_OBJ_1(mod_blst_aggregate_sigs_obj, mod_blst_aggregate_sigs); */


static mp_obj_t mod_blst_aggregate_pks(mp_obj_t pks_obj) {
    mp_obj_t* pk_items;
    size_t num_pks;
    mp_obj_get_array(pks_obj, &num_pks, &pk_items);
    if (num_pks == 0) {

        mp_raise_msg(&mp_type_ValueError, MP_ERROR_TEXT("No public keys to aggregate"));
    }


    uint8_t** pks = m_new(uint8_t*, num_pks);
    size_t* pk_lens = m_new(size_t, num_pks);
    for (size_t i = 0; i < num_pks; i++) {
        if (get_buffer(pk_items[i], &pks[i], &pk_lens[i]) != 0 || pk_lens[i] != PUBLIC_KEY_SIZE) {
            m_del(uint8_t*, pks, num_pks);
            m_del(size_t, pk_lens, num_pks);

            mp_raise_msg(&mp_type_ValueError, MP_ERROR_TEXT("Invalid public key"));
        }
    }



    blst_p1 agg_pk;

    blst_p1_affine pk_aff;
    blst_p1_from_bytes(&agg_pk, pks[0]);

    for (size_t i = 1; i < num_pks; i++) {
        blst_p1_uncompress(&pk_aff, pks[i]);
        blst_p1_add_or_double_affine(&agg_pk, &agg_pk, &pk_aff);
    }

    blst_byte agg_pk_serialized[PUBLIC_KEY_SIZE]; 
    blst_p1_compress(agg_pk_serialized, &agg_pk); 
    m_del(uint8_t*, pks, num_pks);
    m_del(size_t, pk_lens, num_pks);
    return mp_obj_new_bytes(agg_pk_serialized, PUBLIC_KEY_SIZE);
}
/* static MP_DEFINE_CONST_FUN_OBJ_1(mod_blst_aggregate_pks_obj, mod_blst_aggregate_pks); */



static mp_obj_t mod_blst_aggregate(mp_obj_t sigs_or_pks_obj) {

    mp_obj_t* items;
    size_t num;
    mp_obj_get_array(sigs_or_pks_obj, &num, &items);
    if (num == 0) {

        mp_raise_msg(&mp_type_ValueError, MP_ERROR_TEXT("Nothing to aggregate"));
    }


    uint8_t** sigs_or_pks = m_new(uint8_t*, num);
    size_t* lens = m_new(size_t, num);
    if (get_buffer(items[0], &sigs_or_pks[0], &lens[0]) != 0) {
            m_del(uint8_t*, sigs_or_pks, num);
            if (lens[0] == PUBLIC_KEY_SIZE){

                m_del(size_t, lens, num);
                mp_raise_msg(&mp_type_ValueError, MP_ERROR_TEXT("Invalid public key"));
        }
            if (lens[0] == SIGNATURE_SIZE ){
                
                m_del(size_t, lens, num);

                mp_raise_msg(&mp_type_ValueError, MP_ERROR_TEXT("Invalid signature"));

        }
        else{

            m_del(size_t, lens, num);
            mp_raise_msg(&mp_type_ValueError, MP_ERROR_TEXT("Invalid element"));
        }
    }

    m_del(uint8_t*, sigs_or_pks, num);

    if (lens[0] == PUBLIC_KEY_SIZE){

        m_del(size_t, lens, num);
        return mod_blst_aggregate_pks(sigs_or_pks_obj);
    }
    else if (lens[0] == SIGNATURE_SIZE){

        m_del(size_t, lens, num);
        return mod_blst_aggregate_sigs(sigs_or_pks_obj);
    } 
    else{

        m_del(size_t, lens, num);
        mp_raise_msg(&mp_type_ValueError, MP_ERROR_TEXT("Invalid elements"));
    }

}
static MP_DEFINE_CONST_FUN_OBJ_1(mod_blst_aggregate_obj, mod_blst_aggregate);

static mp_obj_t mod_blst_aggregate_verify(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {

	static const mp_arg_t allowed_args[] = {
        { MP_QSTR_pks, MP_ARG_REQUIRED | MP_ARG_OBJ, {.u_rom_obj =  mp_const_none} },
        { MP_QSTR_msgs, MP_ARG_REQUIRED | MP_ARG_OBJ, {.u_rom_obj = mp_const_none} },
        { MP_QSTR_agg_sig, MP_ARG_REQUIRED | MP_ARG_OBJ, {.u_rom_obj = mp_const_none} },
        { MP_QSTR_scheme, MP_ARG_INT | MP_ARG_INT, {.u_int = AUG_SCH} },
    };

    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
    mp_arg_parse_all(n_args, pos_args, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);

    mp_obj_t pks_obj = args[0].u_obj;
    mp_obj_t msgs_obj = args[1].u_obj;
    mp_obj_t agg_sig_obj = args[2].u_obj;

    mp_obj_t* pk_items, *msg_items;
    size_t num_pks, num_msgs;
    mp_obj_get_array(pks_obj, &num_pks, &pk_items);
    mp_obj_get_array(msgs_obj, &num_msgs, &msg_items);
    if (num_pks != num_msgs || num_pks == 0) {

        mp_raise_msg(&mp_type_ValueError, MP_ERROR_TEXT("Mismatched or empty PKs and messages"));
    }


    uint8_t* agg_sig;
    size_t agg_sig_len;
    if (get_buffer(agg_sig_obj, &agg_sig, &agg_sig_len) != 0 || agg_sig_len != SIGNATURE_SIZE) {

        mp_raise_msg(&mp_type_ValueError, MP_ERROR_TEXT("Invalid aggregated signature"));
    }


    uint8_t** pks = m_new(uint8_t*, num_pks);
    uint8_t** msgs = m_new(uint8_t*, num_msgs);
    size_t* msg_lens = m_new(size_t, num_msgs);


    for (size_t i = 0; i < num_pks; i++) {
        size_t pk_len;
        if (get_buffer(pk_items[i], &pks[i], &pk_len) != 0 || pk_len != PUBLIC_KEY_SIZE) {
            m_del(uint8_t*, pks, num_pks);
            m_del(uint8_t*, msgs, num_msgs);
            m_del(size_t, msg_lens, num_msgs);

            mp_raise_msg(&mp_type_ValueError, MP_ERROR_TEXT("Invalid public key"));
        }
        if (get_buffer(msg_items[i], &msgs[i], &msg_lens[i]) != 0) {
            m_del(uint8_t*, pks, num_pks);
            m_del(uint8_t*, msgs, num_msgs);
            m_del(size_t, msg_lens, num_msgs);

            mp_raise_msg(&mp_type_ValueError, MP_ERROR_TEXT("Invalid message"));
        }
    }


    int result = bls_aggregate_verify((const uint8_t**)pks, (const uint8_t**)msgs, msg_lens, num_msgs, agg_sig, args[3].u_int);

    m_del(uint8_t*, pks, num_pks);
    m_del(uint8_t*, msgs, num_msgs);
    m_del(size_t, msg_lens, num_msgs);
    return mp_obj_new_bool(result == 0);
}
static MP_DEFINE_CONST_FUN_OBJ_KW(mod_blst_aggregate_verify_obj, 3, mod_blst_aggregate_verify);
// Define all attributes of the module.
// Table entries are key/value pairs of the attribute name (a string)
// and the MicroPython object reference.
// All identifiers and strings are written as MP_QSTR_xxx and will be
// optimized to word-sized integers by the build system (interned strings).
static const mp_rom_map_elem_t mp_module_blst_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_blst) },
    { MP_ROM_QSTR(MP_QSTR_keygen), MP_ROM_PTR(&mod_blst_keygen_obj) },
    { MP_ROM_QSTR(MP_QSTR_keygen_v3), MP_ROM_PTR(&mod_blst_keygen_v3_obj) },
    { MP_ROM_QSTR(MP_QSTR_derive_child_sk), MP_ROM_PTR(&mod_blst_derive_child_sk_v3_obj) },
    { MP_ROM_QSTR(MP_QSTR_keygen_dm_eip2333), MP_ROM_PTR(&mod_blst_derive_master_eip2333_obj) },
    { MP_ROM_QSTR(MP_QSTR_keygen_dc_eip2333), MP_ROM_PTR(&mod_blst_derive_child_eip2333_obj) },
    { MP_ROM_QSTR(MP_QSTR_pubkey), MP_ROM_PTR(&mod_blst_pubk_obj) },
    { MP_ROM_QSTR(MP_QSTR_sign), MP_ROM_PTR(&mod_blst_sign_obj) },
    { MP_ROM_QSTR(MP_QSTR_verify), MP_ROM_PTR(&mod_blst_verify_obj) },
    { MP_ROM_QSTR(MP_QSTR_aggregate), MP_ROM_PTR(&mod_blst_aggregate_obj) },
    { MP_ROM_QSTR(MP_QSTR_aggregate_verify), MP_ROM_PTR(&mod_blst_aggregate_verify_obj) },
	{ MP_ROM_QSTR(MP_QSTR_BASIC_SCHEME_MPL), MP_ROM_INT(BASIC_SCH) },
	{ MP_ROM_QSTR(MP_QSTR_AUG_SCHEME_MPL), MP_ROM_INT(AUG_SCH) },
	{ MP_ROM_QSTR(MP_QSTR_POP_SCHEME_MPL), MP_ROM_INT(POP_SCH) },
};
static MP_DEFINE_CONST_DICT(mp_module_blst_globals, mp_module_blst_globals_table);

// Define module object.
const mp_obj_module_t mp_module_blst = {
    .base = { &mp_type_module },
    .globals = (mp_obj_dict_t *)&mp_module_blst_globals,
};

// Register the module to make it available in Python.
MP_REGISTER_MODULE(MP_QSTR_blst, mp_module_blst);
